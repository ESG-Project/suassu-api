// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const createProject = `-- name: CreateProject :one
INSERT INTO "Project" (
    id,
    title,
    cnpj,
    activity,
    codram,
    "usefulArea",
    "totalArea",
    "pollutingPower",
    stage,
    situation,
    "addressId",
    "clientId",
    size
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, cnpj, activity, codram, "usefulArea", "totalArea", "pollutingPower", stage, situation, "addressId", "clientId", size
`

type CreateProjectParams struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Cnpj           sql.NullString `json:"cnpj"`
	Activity       string         `json:"activity"`
	Codram         sql.NullString `json:"codram"`
	UsefulArea     sql.NullString `json:"usefulArea"`
	TotalArea      sql.NullString `json:"totalArea"`
	PollutingPower sql.NullString `json:"pollutingPower"`
	Stage          sql.NullString `json:"stage"`
	Situation      sql.NullString `json:"situation"`
	AddressId      string         `json:"addressId"`
	ClientId       string         `json:"clientId"`
	Size           sql.NullString `json:"size"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.ID,
		arg.Title,
		arg.Cnpj,
		arg.Activity,
		arg.Codram,
		arg.UsefulArea,
		arg.TotalArea,
		arg.PollutingPower,
		arg.Stage,
		arg.Situation,
		arg.AddressId,
		arg.ClientId,
		arg.Size,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Cnpj,
		&i.Activity,
		&i.Codram,
		&i.UsefulArea,
		&i.TotalArea,
		&i.PollutingPower,
		&i.Stage,
		&i.Situation,
		&i.AddressId,
		&i.ClientId,
		&i.Size,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM "Project"
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT 
    p.id,
    p.title,
    p.cnpj,
    p.activity,
    p.codram,
    p."usefulArea",
    p."totalArea",
    p."pollutingPower",
    p.stage,
    p.situation,
    p."addressId",
    p."clientId",
    p.size,
    a."zipCode",
    a.state,
    a.city,
    a.neighborhood,
    a.street,
    a.num,
    a.latitude,
    a.longitude,
    a."addInfo"
FROM "Project" p
LEFT JOIN "Address" a ON p."addressId" = a.id
WHERE p.id = $1
LIMIT 1
`

type GetProjectByIDRow struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Cnpj           sql.NullString `json:"cnpj"`
	Activity       string         `json:"activity"`
	Codram         sql.NullString `json:"codram"`
	UsefulArea     sql.NullString `json:"usefulArea"`
	TotalArea      sql.NullString `json:"totalArea"`
	PollutingPower sql.NullString `json:"pollutingPower"`
	Stage          sql.NullString `json:"stage"`
	Situation      sql.NullString `json:"situation"`
	AddressId      string         `json:"addressId"`
	ClientId       string         `json:"clientId"`
	Size           sql.NullString `json:"size"`
	ZipCode        sql.NullString `json:"zipCode"`
	State          sql.NullString `json:"state"`
	City           sql.NullString `json:"city"`
	Neighborhood   sql.NullString `json:"neighborhood"`
	Street         sql.NullString `json:"street"`
	Num            sql.NullString `json:"num"`
	Latitude       sql.NullString `json:"latitude"`
	Longitude      sql.NullString `json:"longitude"`
	AddInfo        sql.NullString `json:"addInfo"`
}

func (q *Queries) GetProjectByID(ctx context.Context, id string) (GetProjectByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Cnpj,
		&i.Activity,
		&i.Codram,
		&i.UsefulArea,
		&i.TotalArea,
		&i.PollutingPower,
		&i.Stage,
		&i.Situation,
		&i.AddressId,
		&i.ClientId,
		&i.Size,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Neighborhood,
		&i.Street,
		&i.Num,
		&i.Latitude,
		&i.Longitude,
		&i.AddInfo,
	)
	return i, err
}

const listAllProjects = `-- name: ListAllProjects :many
SELECT 
    p.id,
    p.title,
    p.cnpj,
    p.activity,
    p.stage,
    p.situation,
    p."clientId"
FROM "Project" p
ORDER BY p.title ASC
LIMIT $1 OFFSET $2
`

type ListAllProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllProjectsRow struct {
	ID        string         `json:"id"`
	Title     string         `json:"title"`
	Cnpj      sql.NullString `json:"cnpj"`
	Activity  string         `json:"activity"`
	Stage     sql.NullString `json:"stage"`
	Situation sql.NullString `json:"situation"`
	ClientId  string         `json:"clientId"`
}

func (q *Queries) ListAllProjects(ctx context.Context, arg ListAllProjectsParams) ([]ListAllProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllProjectsRow
	for rows.Next() {
		var i ListAllProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Cnpj,
			&i.Activity,
			&i.Stage,
			&i.Situation,
			&i.ClientId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByClient = `-- name: ListProjectsByClient :many
SELECT 
    p.id,
    p.title,
    p.cnpj,
    p.activity,
    p.stage,
    p.situation,
    p."clientId"
FROM "Project" p
WHERE p."clientId" = $1
ORDER BY p.title ASC
`

type ListProjectsByClientRow struct {
	ID        string         `json:"id"`
	Title     string         `json:"title"`
	Cnpj      sql.NullString `json:"cnpj"`
	Activity  string         `json:"activity"`
	Stage     sql.NullString `json:"stage"`
	Situation sql.NullString `json:"situation"`
	ClientId  string         `json:"clientId"`
}

func (q *Queries) ListProjectsByClient(ctx context.Context, clientid string) ([]ListProjectsByClientRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsByClient, clientid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsByClientRow
	for rows.Next() {
		var i ListProjectsByClientRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Cnpj,
			&i.Activity,
			&i.Stage,
			&i.Situation,
			&i.ClientId,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :exec
UPDATE "Project"
SET
    title = $2,
    cnpj = $3,
    activity = $4,
    codram = $5,
    "usefulArea" = $6,
    "totalArea" = $7,
    "pollutingPower" = $8,
    stage = $9,
    situation = $10,
    size = $11
WHERE id = $1
`

type UpdateProjectParams struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Cnpj           sql.NullString `json:"cnpj"`
	Activity       string         `json:"activity"`
	Codram         sql.NullString `json:"codram"`
	UsefulArea     sql.NullString `json:"usefulArea"`
	TotalArea      sql.NullString `json:"totalArea"`
	PollutingPower sql.NullString `json:"pollutingPower"`
	Stage          sql.NullString `json:"stage"`
	Situation      sql.NullString `json:"situation"`
	Size           sql.NullString `json:"size"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject,
		arg.ID,
		arg.Title,
		arg.Cnpj,
		arg.Activity,
		arg.Codram,
		arg.UsefulArea,
		arg.TotalArea,
		arg.PollutingPower,
		arg.Stage,
		arg.Situation,
		arg.Size,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: species.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"
)

const createSpecies = `-- name: CreateSpecies :one
INSERT INTO public.species (
    id,
    scientific_name,
    family,
    popular_name,
    species_detail_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, scientific_name, family, popular_name, species_detail_id, created_at, updated_at
`

type CreateSpeciesParams struct {
	ID              string         `json:"id"`
	ScientificName  string         `json:"scientific_name"`
	Family          string         `json:"family"`
	PopularName     sql.NullString `json:"popular_name"`
	SpeciesDetailID string         `json:"species_detail_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) CreateSpecies(ctx context.Context, arg CreateSpeciesParams) (Species, error) {
	row := q.db.QueryRowContext(ctx, createSpecies,
		arg.ID,
		arg.ScientificName,
		arg.Family,
		arg.PopularName,
		arg.SpeciesDetailID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Species
	err := row.Scan(
		&i.ID,
		&i.ScientificName,
		&i.Family,
		&i.PopularName,
		&i.SpeciesDetailID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSpeciesLegislation = `-- name: CreateSpeciesLegislation :one
INSERT INTO public.species_details (
    id,
    law_scope,
    law_id,
    is_law_active,
    species_form_factor,
    is_species_protected,
    species_threat_status,
    successional_ecology,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, law_scope, law_id, is_law_active, species_form_factor, is_species_protected, species_threat_status, successional_ecology, created_at, updated_at
`

type CreateSpeciesLegislationParams struct {
	ID                  string       `json:"id"`
	LawScope            LawScope     `json:"law_scope"`
	LawID               string       `json:"law_id"`
	IsLawActive         bool         `json:"is_law_active"`
	SpeciesFormFactor   string       `json:"species_form_factor"`
	IsSpeciesProtected  bool         `json:"is_species_protected"`
	SpeciesThreatStatus ThreatStatus `json:"species_threat_status"`
	SuccessionalEcology OriginType   `json:"successional_ecology"`
	CreatedAt           time.Time    `json:"created_at"`
	UpdatedAt           time.Time    `json:"updated_at"`
}

func (q *Queries) CreateSpeciesLegislation(ctx context.Context, arg CreateSpeciesLegislationParams) (SpeciesDetail, error) {
	row := q.db.QueryRowContext(ctx, createSpeciesLegislation,
		arg.ID,
		arg.LawScope,
		arg.LawID,
		arg.IsLawActive,
		arg.SpeciesFormFactor,
		arg.IsSpeciesProtected,
		arg.SpeciesThreatStatus,
		arg.SuccessionalEcology,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SpeciesDetail
	err := row.Scan(
		&i.ID,
		&i.LawScope,
		&i.LawID,
		&i.IsLawActive,
		&i.SpeciesFormFactor,
		&i.IsSpeciesProtected,
		&i.SpeciesThreatStatus,
		&i.SuccessionalEcology,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpeciesByID = `-- name: GetSpeciesByID :one
SELECT 
    s.id,
    s.scientific_name,
    s.family,
    s.popular_name,
    s.species_detail_id,
    s.created_at,
    s.updated_at,
    sd.law_scope,
    sd.law_id,
    sd.is_law_active,
    sd.species_form_factor,
    sd.is_species_protected,
    sd.species_threat_status,
    sd.successional_ecology,
    sd.created_at AS detail_created_at,
    sd.updated_at AS detail_updated_at
FROM public.species s
INNER JOIN public.species_details sd ON s.species_detail_id = sd.id
WHERE s.id = $1
LIMIT 1
`

type GetSpeciesByIDRow struct {
	ID                  string         `json:"id"`
	ScientificName      string         `json:"scientific_name"`
	Family              string         `json:"family"`
	PopularName         sql.NullString `json:"popular_name"`
	SpeciesDetailID     string         `json:"species_detail_id"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	LawScope            LawScope       `json:"law_scope"`
	LawID               string         `json:"law_id"`
	IsLawActive         bool           `json:"is_law_active"`
	SpeciesFormFactor   string         `json:"species_form_factor"`
	IsSpeciesProtected  bool           `json:"is_species_protected"`
	SpeciesThreatStatus ThreatStatus   `json:"species_threat_status"`
	SuccessionalEcology OriginType     `json:"successional_ecology"`
	DetailCreatedAt     time.Time      `json:"detail_created_at"`
	DetailUpdatedAt     time.Time      `json:"detail_updated_at"`
}

func (q *Queries) GetSpeciesByID(ctx context.Context, id string) (GetSpeciesByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeciesByID, id)
	var i GetSpeciesByIDRow
	err := row.Scan(
		&i.ID,
		&i.ScientificName,
		&i.Family,
		&i.PopularName,
		&i.SpeciesDetailID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LawScope,
		&i.LawID,
		&i.IsLawActive,
		&i.SpeciesFormFactor,
		&i.IsSpeciesProtected,
		&i.SpeciesThreatStatus,
		&i.SuccessionalEcology,
		&i.DetailCreatedAt,
		&i.DetailUpdatedAt,
	)
	return i, err
}

const getSpeciesByScientificName = `-- name: GetSpeciesByScientificName :one
SELECT 
    s.id,
    s.scientific_name,
    s.family,
    s.popular_name,
    s.species_detail_id,
    s.created_at,
    s.updated_at,
    sd.law_scope,
    sd.law_id,
    sd.is_law_active,
    sd.species_form_factor,
    sd.is_species_protected,
    sd.species_threat_status,
    sd.successional_ecology,
    sd.created_at AS detail_created_at,
    sd.updated_at AS detail_updated_at
FROM public.species s
INNER JOIN public.species_details sd ON s.species_detail_id = sd.id
WHERE s.scientific_name = $1
LIMIT 1
`

type GetSpeciesByScientificNameRow struct {
	ID                  string         `json:"id"`
	ScientificName      string         `json:"scientific_name"`
	Family              string         `json:"family"`
	PopularName         sql.NullString `json:"popular_name"`
	SpeciesDetailID     string         `json:"species_detail_id"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	LawScope            LawScope       `json:"law_scope"`
	LawID               string         `json:"law_id"`
	IsLawActive         bool           `json:"is_law_active"`
	SpeciesFormFactor   string         `json:"species_form_factor"`
	IsSpeciesProtected  bool           `json:"is_species_protected"`
	SpeciesThreatStatus ThreatStatus   `json:"species_threat_status"`
	SuccessionalEcology OriginType     `json:"successional_ecology"`
	DetailCreatedAt     time.Time      `json:"detail_created_at"`
	DetailUpdatedAt     time.Time      `json:"detail_updated_at"`
}

func (q *Queries) GetSpeciesByScientificName(ctx context.Context, scientificName string) (GetSpeciesByScientificNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeciesByScientificName, scientificName)
	var i GetSpeciesByScientificNameRow
	err := row.Scan(
		&i.ID,
		&i.ScientificName,
		&i.Family,
		&i.PopularName,
		&i.SpeciesDetailID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LawScope,
		&i.LawID,
		&i.IsLawActive,
		&i.SpeciesFormFactor,
		&i.IsSpeciesProtected,
		&i.SpeciesThreatStatus,
		&i.SuccessionalEcology,
		&i.DetailCreatedAt,
		&i.DetailUpdatedAt,
	)
	return i, err
}

const listSpecies = `-- name: ListSpecies :many
SELECT 
    s.id,
    s.scientific_name,
    s.family,
    s.popular_name,
    s.species_detail_id,
    s.created_at,
    s.updated_at,
    sd.law_scope,
    sd.law_id,
    sd.is_law_active,
    sd.species_form_factor,
    sd.is_species_protected,
    sd.species_threat_status,
    sd.successional_ecology
FROM public.species s
INNER JOIN public.species_details sd ON s.species_detail_id = sd.id
ORDER BY s.scientific_name ASC
LIMIT $1 OFFSET $2
`

type ListSpeciesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSpeciesRow struct {
	ID                  string         `json:"id"`
	ScientificName      string         `json:"scientific_name"`
	Family              string         `json:"family"`
	PopularName         sql.NullString `json:"popular_name"`
	SpeciesDetailID     string         `json:"species_detail_id"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	LawScope            LawScope       `json:"law_scope"`
	LawID               string         `json:"law_id"`
	IsLawActive         bool           `json:"is_law_active"`
	SpeciesFormFactor   string         `json:"species_form_factor"`
	IsSpeciesProtected  bool           `json:"is_species_protected"`
	SpeciesThreatStatus ThreatStatus   `json:"species_threat_status"`
	SuccessionalEcology OriginType     `json:"successional_ecology"`
}

func (q *Queries) ListSpecies(ctx context.Context, arg ListSpeciesParams) ([]ListSpeciesRow, error) {
	rows, err := q.db.QueryContext(ctx, listSpecies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSpeciesRow
	for rows.Next() {
		var i ListSpeciesRow
		if err := rows.Scan(
			&i.ID,
			&i.ScientificName,
			&i.Family,
			&i.PopularName,
			&i.SpeciesDetailID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LawScope,
			&i.LawID,
			&i.IsLawActive,
			&i.SpeciesFormFactor,
			&i.IsSpeciesProtected,
			&i.SpeciesThreatStatus,
			&i.SuccessionalEcology,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpecies = `-- name: UpdateSpecies :exec
UPDATE public.species
SET
    scientific_name = $2,
    family = $3,
    popular_name = $4,
    updated_at = $5
WHERE id = $1
`

type UpdateSpeciesParams struct {
	ID             string         `json:"id"`
	ScientificName string         `json:"scientific_name"`
	Family         string         `json:"family"`
	PopularName    sql.NullString `json:"popular_name"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) UpdateSpecies(ctx context.Context, arg UpdateSpeciesParams) error {
	_, err := q.db.ExecContext(ctx, updateSpecies,
		arg.ID,
		arg.ScientificName,
		arg.Family,
		arg.PopularName,
		arg.UpdatedAt,
	)
	return err
}

const updateSpeciesLegislation = `-- name: UpdateSpeciesLegislation :exec
UPDATE public.species_details
SET
    law_scope = $2,
    law_id = $3,
    is_law_active = $4,
    species_form_factor = $5,
    is_species_protected = $6,
    species_threat_status = $7,
    successional_ecology = $8,
    updated_at = $9
WHERE id = $1
`

type UpdateSpeciesLegislationParams struct {
	ID                  string       `json:"id"`
	LawScope            LawScope     `json:"law_scope"`
	LawID               string       `json:"law_id"`
	IsLawActive         bool         `json:"is_law_active"`
	SpeciesFormFactor   string       `json:"species_form_factor"`
	IsSpeciesProtected  bool         `json:"is_species_protected"`
	SpeciesThreatStatus ThreatStatus `json:"species_threat_status"`
	SuccessionalEcology OriginType   `json:"successional_ecology"`
	UpdatedAt           time.Time    `json:"updated_at"`
}

func (q *Queries) UpdateSpeciesLegislation(ctx context.Context, arg UpdateSpeciesLegislationParams) error {
	_, err := q.db.ExecContext(ctx, updateSpeciesLegislation,
		arg.ID,
		arg.LawScope,
		arg.LawID,
		arg.IsLawActive,
		arg.SpeciesFormFactor,
		arg.IsSpeciesProtected,
		arg.SpeciesThreatStatus,
		arg.SuccessionalEcology,
		arg.UpdatedAt,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: enterprise.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const createEnterprise = `-- name: CreateEnterprise :exec
INSERT INTO "Enterprise" (
    "id",
    "cnpj",
    "addressId",
    "email",
    "fantasyName",
    "name",
    "phone"
  )
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateEnterpriseParams struct {
	ID          string         `json:"id"`
	Cnpj        string         `json:"cnpj"`
	AddressId   sql.NullString `json:"addressId"`
	Email       string         `json:"email"`
	FantasyName sql.NullString `json:"fantasyName"`
	Name        string         `json:"name"`
	Phone       sql.NullString `json:"phone"`
}

func (q *Queries) CreateEnterprise(ctx context.Context, arg CreateEnterpriseParams) error {
	_, err := q.db.ExecContext(ctx, createEnterprise,
		arg.ID,
		arg.Cnpj,
		arg.AddressId,
		arg.Email,
		arg.FantasyName,
		arg.Name,
		arg.Phone,
	)
	return err
}

const getEnterpriseByID = `-- name: GetEnterpriseByID :one
SELECT e.id,
  e.cnpj,
  e.email,
  e.name,
  e."fantasyName",
  e.phone,
  e."addressId",
  a."zipCode" AS zip_code,
  a.state,
  a.city,
  a.neighborhood,
  a.street,
  a.num,
  a.latitude,
  a.longitude,
  a."addInfo" AS add_info,
  -- agrega products como JSON ([] quando não houver)
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        'id', p.id,
        'name', p.name,
        'suggestedValue', p."suggestedValue",
        'enterpriseId', p."enterpriseId",
        'parameterId', p."parameterId",
        'deliverable', p.deliverable,
        'typeProductId', p."typeProductId",
        'isDefault', p."isDefault"
      )
    ) FILTER (WHERE p.id IS NOT NULL),
    '[]'
  ) AS products,
  -- agrega parameters como JSON ([] quando não houver)
  COALESCE(
    json_agg(
      DISTINCT jsonb_build_object(
        'id', pr.id,
        'title', pr.title,
        'value', pr.value,
        'enterpriseId', pr."enterpriseId",
        'isDefault', pr."isDefault"
      )
    ) FILTER (WHERE pr.id IS NOT NULL),
    '[]'
  ) AS parameters
FROM "Enterprise" e
  JOIN "Address" a ON e."addressId" = a.id
  LEFT JOIN "Product" p ON p."enterpriseId" = e.id
  LEFT JOIN "Parameter" pr ON pr."enterpriseId" = e.id
WHERE e.id = $1
GROUP BY e.id,
  a.id
LIMIT 1
`

type GetEnterpriseByIDRow struct {
	ID           string         `json:"id"`
	Cnpj         string         `json:"cnpj"`
	Email        string         `json:"email"`
	Name         string         `json:"name"`
	FantasyName  sql.NullString `json:"fantasyName"`
	Phone        sql.NullString `json:"phone"`
	AddressId    sql.NullString `json:"addressId"`
	ZipCode      string         `json:"zip_code"`
	State        string         `json:"state"`
	City         string         `json:"city"`
	Neighborhood string         `json:"neighborhood"`
	Street       string         `json:"street"`
	Num          string         `json:"num"`
	Latitude     sql.NullString `json:"latitude"`
	Longitude    sql.NullString `json:"longitude"`
	AddInfo      sql.NullString `json:"add_info"`
	Products     interface{}    `json:"products"`
	Parameters   interface{}    `json:"parameters"`
}

func (q *Queries) GetEnterpriseByID(ctx context.Context, id string) (GetEnterpriseByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getEnterpriseByID, id)
	var i GetEnterpriseByIDRow
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Email,
		&i.Name,
		&i.FantasyName,
		&i.Phone,
		&i.AddressId,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Neighborhood,
		&i.Street,
		&i.Num,
		&i.Latitude,
		&i.Longitude,
		&i.AddInfo,
		&i.Products,
		&i.Parameters,
	)
	return i, err
}

const updateEnterprise = `-- name: UpdateEnterprise :exec
UPDATE "Enterprise"
SET "cnpj" = $2,
  "addressId" = $3,
  "email" = $4,
  "fantasyName" = $5,
  "name" = $6,
  "phone" = $7
WHERE id = $1
`

type UpdateEnterpriseParams struct {
	ID          string         `json:"id"`
	Cnpj        string         `json:"cnpj"`
	AddressId   sql.NullString `json:"addressId"`
	Email       string         `json:"email"`
	FantasyName sql.NullString `json:"fantasyName"`
	Name        string         `json:"name"`
	Phone       sql.NullString `json:"phone"`
}

func (q *Queries) UpdateEnterprise(ctx context.Context, arg UpdateEnterpriseParams) error {
	_, err := q.db.ExecContext(ctx, updateEnterprise,
		arg.ID,
		arg.Cnpj,
		arg.AddressId,
		arg.Email,
		arg.FantasyName,
		arg.Name,
		arg.Phone,
	)
	return err
}

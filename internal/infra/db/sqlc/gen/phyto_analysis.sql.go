// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: phyto_analysis.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"
)

const createPhytoAnalysis = `-- name: CreatePhytoAnalysis :one
INSERT INTO public.phyto_analyses (
    id,
    title,
    initial_date,
    portion_quantity,
    portion_area,
    total_area,
    sampled_area,
    description,
    project_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, title, initial_date, portion_quantity, portion_area, total_area, sampled_area, description, project_id, created_at, updated_at
`

type CreatePhytoAnalysisParams struct {
	ID              string         `json:"id"`
	Title           string         `json:"title"`
	InitialDate     time.Time      `json:"initial_date"`
	PortionQuantity int32          `json:"portion_quantity"`
	PortionArea     string         `json:"portion_area"`
	TotalArea       string         `json:"total_area"`
	SampledArea     string         `json:"sampled_area"`
	Description     sql.NullString `json:"description"`
	ProjectID       string         `json:"project_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) CreatePhytoAnalysis(ctx context.Context, arg CreatePhytoAnalysisParams) (PhytoAnalysis, error) {
	row := q.db.QueryRowContext(ctx, createPhytoAnalysis,
		arg.ID,
		arg.Title,
		arg.InitialDate,
		arg.PortionQuantity,
		arg.PortionArea,
		arg.TotalArea,
		arg.SampledArea,
		arg.Description,
		arg.ProjectID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PhytoAnalysis
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.InitialDate,
		&i.PortionQuantity,
		&i.PortionArea,
		&i.TotalArea,
		&i.SampledArea,
		&i.Description,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePhytoAnalysis = `-- name: DeletePhytoAnalysis :exec
DELETE FROM public.phyto_analyses
WHERE id = $1
`

func (q *Queries) DeletePhytoAnalysis(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePhytoAnalysis, id)
	return err
}

const getPhytoAnalysisByID = `-- name: GetPhytoAnalysisByID :one
SELECT 
    pa.id,
    pa.title,
    pa.initial_date,
    pa.portion_quantity,
    pa.portion_area,
    pa.total_area,
    pa.sampled_area,
    pa.description,
    pa.project_id,
    pa.created_at,
    pa.updated_at,
    p.title AS project_title,
    p.cnpj AS project_cnpj,
    p.activity AS project_activity,
    p."clientId" AS project_client_id
FROM public.phyto_analyses pa
INNER JOIN public."Project" p ON pa.project_id = p.id
WHERE pa.id = $1
LIMIT 1
`

type GetPhytoAnalysisByIDRow struct {
	ID              string         `json:"id"`
	Title           string         `json:"title"`
	InitialDate     time.Time      `json:"initial_date"`
	PortionQuantity int32          `json:"portion_quantity"`
	PortionArea     string         `json:"portion_area"`
	TotalArea       string         `json:"total_area"`
	SampledArea     string         `json:"sampled_area"`
	Description     sql.NullString `json:"description"`
	ProjectID       string         `json:"project_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	ProjectTitle    string         `json:"project_title"`
	ProjectCnpj     sql.NullString `json:"project_cnpj"`
	ProjectActivity string         `json:"project_activity"`
	ProjectClientID string         `json:"project_client_id"`
}

func (q *Queries) GetPhytoAnalysisByID(ctx context.Context, id string) (GetPhytoAnalysisByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPhytoAnalysisByID, id)
	var i GetPhytoAnalysisByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.InitialDate,
		&i.PortionQuantity,
		&i.PortionArea,
		&i.TotalArea,
		&i.SampledArea,
		&i.Description,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectTitle,
		&i.ProjectCnpj,
		&i.ProjectActivity,
		&i.ProjectClientID,
	)
	return i, err
}

const getPhytoAnalysisWithSpecimens = `-- name: GetPhytoAnalysisWithSpecimens :many
SELECT 
    pa.id AS phyto_id,
    pa.title AS phyto_title,
    pa.initial_date,
    pa.portion_quantity,
    pa.portion_area,
    pa.total_area,
    pa.sampled_area,
    pa.description AS phyto_description,
    pa.project_id,
    pa.created_at AS phyto_created_at,
    pa.updated_at AS phyto_updated_at,
    p.title AS project_title,
    p.cnpj AS project_cnpj,
    p.activity AS project_activity,
    p."clientId" AS project_client_id,
    sp.id AS specimen_id,
    sp.portion,
    sp.height,
    sp.cap1,
    sp.cap2,
    sp.cap3,
    sp.cap4,
    sp.cap5,
    sp.cap6,
    sp.average_dap,
    sp.basal_area,
    sp.volume,
    sp.register_date,
    sp.specie_id,
    s.scientific_name,
    s.family,
    s.popular_name
FROM public.phyto_analyses pa
INNER JOIN public."Project" p ON pa.project_id = p.id
LEFT JOIN public.specimens sp ON sp.phyto_analysis_id = pa.id
LEFT JOIN public.species s ON sp.specie_id = s.id
WHERE pa.id = $1
ORDER BY sp.portion ASC, sp.created_at ASC
`

type GetPhytoAnalysisWithSpecimensRow struct {
	PhytoID          string         `json:"phyto_id"`
	PhytoTitle       string         `json:"phyto_title"`
	InitialDate      time.Time      `json:"initial_date"`
	PortionQuantity  int32          `json:"portion_quantity"`
	PortionArea      string         `json:"portion_area"`
	TotalArea        string         `json:"total_area"`
	SampledArea      string         `json:"sampled_area"`
	PhytoDescription sql.NullString `json:"phyto_description"`
	ProjectID        string         `json:"project_id"`
	PhytoCreatedAt   time.Time      `json:"phyto_created_at"`
	PhytoUpdatedAt   time.Time      `json:"phyto_updated_at"`
	ProjectTitle     string         `json:"project_title"`
	ProjectCnpj      sql.NullString `json:"project_cnpj"`
	ProjectActivity  string         `json:"project_activity"`
	ProjectClientID  string         `json:"project_client_id"`
	SpecimenID       sql.NullString `json:"specimen_id"`
	Portion          sql.NullString `json:"portion"`
	Height           sql.NullString `json:"height"`
	Cap1             sql.NullString `json:"cap1"`
	Cap2             sql.NullString `json:"cap2"`
	Cap3             sql.NullString `json:"cap3"`
	Cap4             sql.NullString `json:"cap4"`
	Cap5             sql.NullString `json:"cap5"`
	Cap6             sql.NullString `json:"cap6"`
	AverageDap       sql.NullString `json:"average_dap"`
	BasalArea        sql.NullString `json:"basal_area"`
	Volume           sql.NullString `json:"volume"`
	RegisterDate     sql.NullTime   `json:"register_date"`
	SpecieID         sql.NullString `json:"specie_id"`
	ScientificName   sql.NullString `json:"scientific_name"`
	Family           sql.NullString `json:"family"`
	PopularName      sql.NullString `json:"popular_name"`
}

func (q *Queries) GetPhytoAnalysisWithSpecimens(ctx context.Context, id string) ([]GetPhytoAnalysisWithSpecimensRow, error) {
	rows, err := q.db.QueryContext(ctx, getPhytoAnalysisWithSpecimens, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPhytoAnalysisWithSpecimensRow
	for rows.Next() {
		var i GetPhytoAnalysisWithSpecimensRow
		if err := rows.Scan(
			&i.PhytoID,
			&i.PhytoTitle,
			&i.InitialDate,
			&i.PortionQuantity,
			&i.PortionArea,
			&i.TotalArea,
			&i.SampledArea,
			&i.PhytoDescription,
			&i.ProjectID,
			&i.PhytoCreatedAt,
			&i.PhytoUpdatedAt,
			&i.ProjectTitle,
			&i.ProjectCnpj,
			&i.ProjectActivity,
			&i.ProjectClientID,
			&i.SpecimenID,
			&i.Portion,
			&i.Height,
			&i.Cap1,
			&i.Cap2,
			&i.Cap3,
			&i.Cap4,
			&i.Cap5,
			&i.Cap6,
			&i.AverageDap,
			&i.BasalArea,
			&i.Volume,
			&i.RegisterDate,
			&i.SpecieID,
			&i.ScientificName,
			&i.Family,
			&i.PopularName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllPhytoAnalyses = `-- name: ListAllPhytoAnalyses :many
SELECT 
    pa.id,
    pa.title,
    pa.initial_date,
    pa.portion_quantity,
    pa.portion_area,
    pa.total_area,
    pa.sampled_area,
    pa.description,
    pa.project_id,
    pa.created_at,
    pa.updated_at,
    p.title AS project_title,
    p.cnpj AS project_cnpj,
    p.activity AS project_activity,
    p."clientId" AS project_client_id
FROM public.phyto_analyses pa
INNER JOIN public."Project" p ON pa.project_id = p.id
ORDER BY pa.initial_date DESC, pa.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllPhytoAnalysesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllPhytoAnalysesRow struct {
	ID              string         `json:"id"`
	Title           string         `json:"title"`
	InitialDate     time.Time      `json:"initial_date"`
	PortionQuantity int32          `json:"portion_quantity"`
	PortionArea     string         `json:"portion_area"`
	TotalArea       string         `json:"total_area"`
	SampledArea     string         `json:"sampled_area"`
	Description     sql.NullString `json:"description"`
	ProjectID       string         `json:"project_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	ProjectTitle    string         `json:"project_title"`
	ProjectCnpj     sql.NullString `json:"project_cnpj"`
	ProjectActivity string         `json:"project_activity"`
	ProjectClientID string         `json:"project_client_id"`
}

func (q *Queries) ListAllPhytoAnalyses(ctx context.Context, arg ListAllPhytoAnalysesParams) ([]ListAllPhytoAnalysesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllPhytoAnalyses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllPhytoAnalysesRow
	for rows.Next() {
		var i ListAllPhytoAnalysesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.InitialDate,
			&i.PortionQuantity,
			&i.PortionArea,
			&i.TotalArea,
			&i.SampledArea,
			&i.Description,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.ProjectCnpj,
			&i.ProjectActivity,
			&i.ProjectClientID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPhytoAnalysesByProject = `-- name: ListPhytoAnalysesByProject :many
SELECT 
    pa.id,
    pa.title,
    pa.initial_date,
    pa.portion_quantity,
    pa.portion_area,
    pa.total_area,
    pa.sampled_area,
    pa.description,
    pa.project_id,
    pa.created_at,
    pa.updated_at,
    p.title AS project_title,
    p.cnpj AS project_cnpj,
    p.activity AS project_activity
FROM public.phyto_analyses pa
INNER JOIN public."Project" p ON pa.project_id = p.id
WHERE pa.project_id = $1
ORDER BY pa.initial_date DESC, pa.created_at DESC
`

type ListPhytoAnalysesByProjectRow struct {
	ID              string         `json:"id"`
	Title           string         `json:"title"`
	InitialDate     time.Time      `json:"initial_date"`
	PortionQuantity int32          `json:"portion_quantity"`
	PortionArea     string         `json:"portion_area"`
	TotalArea       string         `json:"total_area"`
	SampledArea     string         `json:"sampled_area"`
	Description     sql.NullString `json:"description"`
	ProjectID       string         `json:"project_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	ProjectTitle    string         `json:"project_title"`
	ProjectCnpj     sql.NullString `json:"project_cnpj"`
	ProjectActivity string         `json:"project_activity"`
}

func (q *Queries) ListPhytoAnalysesByProject(ctx context.Context, projectID string) ([]ListPhytoAnalysesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, listPhytoAnalysesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPhytoAnalysesByProjectRow
	for rows.Next() {
		var i ListPhytoAnalysesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.InitialDate,
			&i.PortionQuantity,
			&i.PortionArea,
			&i.TotalArea,
			&i.SampledArea,
			&i.Description,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectTitle,
			&i.ProjectCnpj,
			&i.ProjectActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePhytoAnalysis = `-- name: UpdatePhytoAnalysis :exec
UPDATE public.phyto_analyses
SET
    title = $2,
    initial_date = $3,
    portion_quantity = $4,
    portion_area = $5,
    total_area = $6,
    sampled_area = $7,
    description = $8,
    updated_at = $9
WHERE id = $1
`

type UpdatePhytoAnalysisParams struct {
	ID              string         `json:"id"`
	Title           string         `json:"title"`
	InitialDate     time.Time      `json:"initial_date"`
	PortionQuantity int32          `json:"portion_quantity"`
	PortionArea     string         `json:"portion_area"`
	TotalArea       string         `json:"total_area"`
	SampledArea     string         `json:"sampled_area"`
	Description     sql.NullString `json:"description"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) UpdatePhytoAnalysis(ctx context.Context, arg UpdatePhytoAnalysisParams) error {
	_, err := q.db.ExecContext(ctx, updatePhytoAnalysis,
		arg.ID,
		arg.Title,
		arg.InitialDate,
		arg.PortionQuantity,
		arg.PortionArea,
		arg.TotalArea,
		arg.SampledArea,
		arg.Description,
		arg.UpdatedAt,
	)
	return err
}
